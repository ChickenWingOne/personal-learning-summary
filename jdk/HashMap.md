### 理解 ###
+ 初始化：当未置顶初始化容量大小的时候，会默认初始化一个大小为16的Entry数组，同时负载因子为0.75。指定容量大小时会有一个tableSizeFor方法，该方法返回最接近该容量大小的2的n次幂
+ put方法：根据key的hashCode再次hash，计算数组索引位置，之后如果当前节点为空，则value直接放进去，不为空的话，则调用key的equals()方法，判断该节点下的链表哪个相等，相等直接覆盖，不相等则将该value放入链表最后（如果链表长度大于8，且数组长度大于64时，会转化为红黑树，目的就是防止hash冲突）
+ remove方法：计算出数组索引位置之后，循环调用equals判断，找到节点之后，将该节点的上一个直接next指向下一个
### 问题 ###
##### 哈希冲突 #####
我们都知道，HashMap底层是以数组+链表的形式组成的，当我们存储<key, value>（其实就是Node）时，HashMap会调用自己本身的hash()算出该Node所在数组位置，之后会放进该位置，如果该位置有值时，则会放到该索引下的链表中。<br/>
假设，该数组初始化时，数组大小为2，我们要放十个Node进去，则计算出同一索引位置的频率是相当高的，也就说哈希冲突频率非常高（明明时间复杂度为O(1)，现在却变成了O(n/2)，需要遍历该链表），所以在jdk1.8之后，HashMap底层链表进行了优化，当链表长度>8时，链表会转化成红黑树，目的就是为了在哈希冲突频率高的时候，提高性能。